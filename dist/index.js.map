{"version":3,"sources":["../src/actions/getQuestStatus.ts","../src/services/raiinmakerService.ts","../src/environment.ts","../src/examples.ts","../src/actions/getDataVerification.ts","../src/actions/verifyGenerationContent.ts","../src/services/contentPreVerificationService.ts","../src/utils/contentExtractor.ts","../src/utils/uuidHelpers.ts","../src/actions/checkVerificationStatus.ts","../src/utils/responseFormatter.ts","../src/index.ts"],"sourcesContent":["import { \n    Action,\n    IAgentRuntime,\n    Memory,\n    State,\n    HandlerCallback,\n    ActionExample,\n    elizaLogger\n} from \"@elizaos/core\";\n\nimport { createRaiinmakerService } from \"../services/raiinmakerService.js\";\nimport { validateRaiinmakerConfig } from \"../environment.js\";\nimport { getQuestStatusExample } from \"../examples.js\";\nimport { Task } from \"../types.js\";\n\n// Helper function to parse dates from natural language\nfunction parseDateRange(text: string): { startDate?: string; endDate?: string } {\n    // This is a simple example - you might want to use a more robust date parsing library\n    const today = new Date();\n    \n    if (text.includes(\"today\")) {\n        return {\n            startDate: today.toISOString().split('T')[0],\n            endDate: today.toISOString().split('T')[0]\n        };\n    }\n    \n    if (text.includes(\"week\")) {\n        const lastWeek = new Date(today);\n        lastWeek.setDate(lastWeek.getDate() - 7);\n        return {\n            startDate: lastWeek.toISOString().split('T')[0],\n            endDate: today.toISOString().split('T')[0]\n        };\n    }\n    \n    if (text.includes(\"month\")) {\n        const lastMonth = new Date(today);\n        lastMonth.setMonth(lastMonth.getMonth() - 1);\n        return {\n            startDate: lastMonth.toISOString().split('T')[0],\n            endDate: today.toISOString().split('T')[0]\n        };\n    }\n    \n    return {};\n}\n\n// Helper function to parse status from message\nfunction parseStatus(text: string): 'completed' | 'pending' | undefined {\n    text = text.toLowerCase();\n    if (text.includes(\"complete\") || text.includes(\"finished\") || text.includes(\"done\")) {\n        return 'completed';\n    }\n    if (text.includes(\"pending\") || text.includes(\"ongoing\") || text.includes(\"active\")) {\n        return 'pending';\n    }\n    return undefined;\n}\n\n// Helper function to parse type from message\nfunction parseType(text: string): 'BOOL' | 'SCALE' | 'TAG' | 'CATEGORY' | undefined {\n    text = text.toLowerCase();\n    if (text.includes(\"category\")) return \"CATEGORY\";\n    if (text.includes(\"scale\")) return \"SCALE\";\n    if (text.includes(\"bool\")) return \"BOOL\";\n    if (text.includes(\"tag\")) return \"TAG\";\n    return undefined;\n}\n\nexport const getQuestStatus: Action = {\n    name: \"GET_RAIIN_QUEST_STATUS\",\n    similes: [\n        \"CHECK_QUEST_STATUS\",\n        \"VIEW_QUEST\",\n        \"GET_QUEST_STATUS\",\n        \"GET_RAIIN_QUEST\"\n    ],\n    description: \"Gets the status of Raiinmaker quests and tasks with optional filtering by date, status, and type\",\n    examples: getQuestStatusExample as ActionExample[][],\n    \n    validate: async (runtime: IAgentRuntime, message: Memory) => {\n        try {\n            await validateRaiinmakerConfig(runtime);\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Validation failed:\", error);\n            return false;\n        }\n    },\n\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state?: State,\n        _options?: { [key: string]: unknown; },\n        callback?: HandlerCallback\n    ) => {\n        try {\n            // Check if credentials were passed from the dispatcher\n            let appId: string;\n            let apiKey: string;\n            \n            if(_options?.credentials && \n                typeof _options.credentials === 'object' &&\n                'appId' in _options.credentials &&\n                'apiKey' in _options.credentials &&\n                typeof _options.credentials.appId === 'string' &&\n                typeof _options.credentials.apiKey === 'string'\n            ) {\n                // Use credentials passed from dispatcher\n                appId = _options.credentials.appId;\n                apiKey = _options.credentials.apiKey;\n            } else {\n                // Try to get global credentials\n                const globalConfig = await validateRaiinmakerConfig(runtime, { allowMissing: true });\n                \n                if (!globalConfig) {\n                    if (callback) {\n                        callback({\n                            text: `No Raiinmaker credentials available. Please set up credentials first.`\n                        });\n                    }\n                    return false;\n                }\n                \n                appId = globalConfig.RAIINMAKER_APP_ID;\n                apiKey = globalConfig.RAIINMAKER_API_KEY;\n            }\n            \n            // Create the service with appropriate credentials\n            const raiinService = createRaiinmakerService(apiKey, appId);\n            \n            // Parse message content for filters\n            const messageText = message.content.text.toLowerCase();\n            const dateRange = parseDateRange(messageText);\n            const status = parseStatus(messageText);\n            const type = parseType(messageText);\n    \n            // Get filtered tasks\n            const tasks = await raiinService.getAllTasks({\n                ...dateRange,\n                status,\n                type\n            });\n            \n            if (tasks.data.items.length === 0) {\n                callback?.({\n                    text: \"I couldn't find any quests matching your criteria. Would you like to see all available quests instead?\"\n                });\n                return false;\n            }\n    \n            // Format response with filter information\n            let responseText = \"Here are your Raiinmaker quests\";\n            if (status) responseText += ` (${status})`;\n            if (type) responseText += ` of type ${type}`;\n            if (dateRange.startDate) responseText += ` from ${dateRange.startDate}`;\n            if (dateRange.endDate) responseText += ` to ${dateRange.endDate}`;\n            responseText += \":\\n\\n\";\n\n            // Format each task\n            const formattedTasks = tasks.data.items.map((task: Task) => ({\n                name: task.name,\n                status: task.status,\n                type: task.type,\n                question: task.question,\n                answer: task.answer,\n                updatedAt: new Date(task.updatedAt).toLocaleString()\n            }));\n\n            responseText += formattedTasks.map((task) => \n                `• ${task.name} (${task.status})\\n` +\n                `  Type: ${task.type}\\n` +\n                `  Question: ${task.question}\\n` +\n                `  ${task.answer ? `Answer: ${task.answer}\\n` : ''}` +\n                `  Last Updated: ${task.updatedAt}`\n            ).join('\\n\\n');\n\n            callback?.({ text: responseText });\n            return true;\n        } catch (error: unknown) {\n            elizaLogger.error(\"Error in getQuestStatus handler:\", error);\n            callback?.({\n                text: \"I apologize, but I'm having trouble retrieving your quest status at the moment. Please try again later.\"\n            });\n            return false;\n        }\n    }\n};","// src/services/raiinmakerService.ts\nimport {\n    Task,\n    AllTasksResponse,\n    AgentValidationResponse,\n    SingleTaskResponse,\n    Vote,\n    TaskWithVotes,\n    CampaignResponse,\n    CreateCampaignParams,\n    UpdateCampaignParams,\n    CreateTaskRequest,\n    CreateTaskResponse\n} from \"../types.js\";\nimport { elizaLogger } from \"@elizaos/core\";\n\n// Custom error class for Raiinmaker API errors\nexport class RaiinmakerApiError extends Error {\n    status?: number;\n    endpoint?: string;\n    details?: any;\n\n    constructor(message: string, options?: { status?: number; endpoint?: string; details?: any }) {\n        super(message);\n        this.name = 'RaiinmakerApiError';\n        this.status = options?.status;\n        this.endpoint = options?.endpoint;\n        this.details = options?.details;\n    }\n}\n\n// Base URL with environment awareness\nconst BASE_URL = process.env.RAIINMAKER_API_URL || \"https://server-staging.api.raiinmaker.com/external\";\n\ninterface TaskQueryParams {\n    page?: number;\n    limit?: number;\n    campaignId?: string;\n    startDate?: string;\n    endDate?: string;\n    status?: 'failed' | 'pending' | 'automatic' | 'completed';\n    type?: 'BOOL' | 'SCALE' | 'TAG' | 'CATEGORY';\n}\n\n// Interface for service configuration - add userId for user-specific tracking\nexport interface RaiinmakerServiceConfig {\n    apiKey: string;\n    appId: string;\n    userId?: string; // Optional user ID for tracking\n}\n\n// Utility function to validate auth credentials \nfunction validateAuth(apiKey: string, appId: string): void {\n    if (!apiKey || typeof apiKey !== 'string') {\n        throw new RaiinmakerApiError(\"API key is required and must be a string\");\n    }\n    if (!appId || typeof appId !== 'string') {\n        throw new RaiinmakerApiError(\"App ID is required and must be a string\");\n    }\n}\n\n// Utility to handle API responses\nasync function handleApiResponse(response: Response, endpoint: string): Promise<any> {\n    if (!response.ok) {\n        let errorMessage = `API error: ${response.status} ${response.statusText}`;\n        let errorDetails = null;\n        \n        try {\n            const errorJson = await response.json();\n            errorMessage = errorJson?.message || errorMessage;\n            errorDetails = errorJson;\n        } catch (parseError) {\n            const errorText = await response.text();\n            errorMessage = errorText || errorMessage;\n        }\n        \n        throw new RaiinmakerApiError(errorMessage, {\n            status: response.status,\n            endpoint,\n            details: errorDetails\n        });\n    }\n    \n    try {\n        return await response.json();\n    } catch (error) {\n        throw new RaiinmakerApiError(`Failed to parse JSON response from ${endpoint}`, {\n            endpoint,\n            details: error\n        });\n    }\n}\n\n/**\n * Creates a Raiinmaker service instance with specified credentials\n * Accepts either individual parameters or a config object with userId\n */\nexport const createRaiinmakerService = (configOrApiKey: RaiinmakerServiceConfig | string, appId?: string) => {\n    // Handle both the config object and traditional parameter style\n    let apiKey: string;\n    let userConfig: RaiinmakerServiceConfig;\n    \n    if (typeof configOrApiKey === 'string') {\n        // Traditional usage pattern\n        if (!appId) {\n            throw new RaiinmakerApiError(\"Both API key and App ID are required\");\n        }\n        \n        apiKey = configOrApiKey;\n        userConfig = {\n            apiKey,\n            appId\n        };\n    } else {\n        // Config object pattern\n        userConfig = configOrApiKey;\n        apiKey = userConfig.apiKey;\n        appId = userConfig.appId;\n    }\n    \n    // Validate credentials\n    validateAuth(apiKey, appId);\n    \n    // Use a consistent base headers object\n    const baseHeaders = {\n        'accept': 'application/json',\n        'appId': appId,\n        'appSecret': apiKey\n    };\n\n    // Log creation with user context if available\n    const logPrefix = userConfig.userId ? `[User: ${userConfig.userId.substring(0, 8)}...]` : '';\n    elizaLogger.info(`${logPrefix} Creating Raiinmaker service with appId: ${appId.substring(0, 4)}...`);\n\n    /**\n     * Retrieves a list of tasks with optional filtering parameters\n     */\n    const getAllTasks = async (params: TaskQueryParams = {}): Promise<AllTasksResponse> => {\n        try {\n            // Build URL with query parameters\n            let url = `${BASE_URL}/task`;\n            const queryParams = new URLSearchParams();\n    \n            // Set default values that meet API requirements, but allow override if valid\n            const page = params.page !== undefined ? params.page : 0;\n            const limit = params.limit !== undefined && params.limit >= 10 ? params.limit : 10;\n            \n            // Add parameters to query string\n            queryParams.append('page', page.toString());\n            queryParams.append('limit', limit.toString());\n            \n            // Add other optional parameters\n            if (params.campaignId) queryParams.append('campaignId', params.campaignId);\n            if (params.startDate) queryParams.append('startDate', params.startDate);\n            if (params.endDate) queryParams.append('endDate', params.endDate);\n            if (params.status) queryParams.append('status', params.status);\n            if (params.type) queryParams.append('type', params.type);\n    \n            // Append query parameters to URL\n            url += `?${queryParams.toString()}`;\n    \n            elizaLogger.info(`${logPrefix} Fetching tasks from ${url}`);\n            \n            const response = await fetch(url, {\n                method: 'GET',\n                headers: baseHeaders\n            });\n            \n            const rawData = await handleApiResponse(response, 'getAllTasks');\n            \n            // Validate response structure\n            if (typeof rawData.success !== 'boolean' || !rawData.data || !Array.isArray(rawData.data.items)) {\n                throw new RaiinmakerApiError('Invalid response format from API', {\n                    endpoint: 'getAllTasks',\n                    details: rawData\n                });\n            }\n    \n            // Return properly validated and typed response\n            const validatedResponse: AllTasksResponse = {\n                success: rawData.success,\n                data: {\n                    items: rawData.data.items,\n                    total: rawData.data.total\n                }\n            };\n    \n            return validatedResponse;\n        } catch (error) {\n            // Enhance error with context if it's not already a RaiinmakerApiError\n            if (!(error instanceof RaiinmakerApiError)) {\n                const err = error as Error;\n                throw new RaiinmakerApiError(`${logPrefix} Error getting tasks: ${err.message}`, {\n                    endpoint: 'getAllTasks',\n                    details: error\n                });\n            }\n            throw error;\n        }\n    };\n\n    /**\n     * Gets a single task by ID with votes\n     */\n    const getTaskById = async (taskId: string): Promise<SingleTaskResponse> => {\n        if (!taskId) {\n            throw new RaiinmakerApiError('Task ID is required');\n        }\n        \n        try {\n            const url = `${BASE_URL}/task/${taskId}`;\n            elizaLogger.info(`${logPrefix} Fetching task with ID: ${taskId}`);\n            \n            const response = await fetch(url, {\n                method: 'GET',\n                headers: baseHeaders\n            });\n            \n            const rawData = await handleApiResponse(response, 'getTaskById');\n            \n            // Perform minimal validation on critical fields\n            if (typeof rawData.success !== 'boolean' || !rawData.data || !rawData.data.id) {\n                throw new RaiinmakerApiError('Invalid task data returned from API', {\n                    endpoint: 'getTaskById',\n                    details: rawData\n                });\n            }\n            \n            // Ensure votes is always an array even if missing in response\n            if (!Array.isArray(rawData.data.votes)) {\n                rawData.data.votes = [];\n            }\n            \n            return {\n                success: rawData.success,\n                data: rawData.data as TaskWithVotes\n            };\n        } catch (error) {\n            if (!(error instanceof RaiinmakerApiError)) {\n                const err = error as Error;\n                throw new RaiinmakerApiError(`${logPrefix} Error getting task by ID: ${err.message}`, {\n                    endpoint: 'getTaskById',\n                    details: { taskId, error }\n                });\n            }\n            throw error;\n        }\n    };\n\n    /**\n     * Verifies data through the agent validation API\n     */\n    const getDataVerification = async (validationData: string): Promise<AgentValidationResponse> => {\n        if (!validationData) {\n            throw new RaiinmakerApiError('Validation data is required');\n        }\n        \n        try {\n            const data = await getAgentValidation(apiKey, appId, validationData);\n            return data;\n        } catch (error) {\n            if (!(error instanceof RaiinmakerApiError)) {\n                const err = error as Error;\n                throw new RaiinmakerApiError(`${logPrefix} Error getting agent validation: ${err.message}`, {\n                    endpoint: 'getDataVerification',\n                    details: error\n                });\n            }\n            throw error;\n        }\n    };\n\n    /**\n     * Creates a FormData object from parameters\n     */\n    const createFormData = (params: Record<string, any>) => {\n        const formData = new FormData();\n        Object.entries(params).forEach(([key, value]) => {\n            if (value !== undefined) {\n                if (value instanceof Blob || value instanceof File) {\n                    formData.append(key, value, 'image.jpg');\n                } else {\n                    formData.append(key, value.toString());\n                }\n            }\n        });\n        return formData;\n    };\n    \n    /**\n     * Creates a new campaign\n     */\n    const createCampaign = async (params: CreateCampaignParams): Promise<CampaignResponse> => {\n        if (!params || !params.name || !params.verificationType) {\n            throw new RaiinmakerApiError('Campaign name and verificationType are required');\n        }\n        \n        try {\n            elizaLogger.info(`${logPrefix} Creating campaign: ${params.name}`);\n            \n            // Create FormData manually to ensure correct structure\n            const formData = new FormData();\n            formData.append('name', params.name);\n            formData.append('verificationType', params.verificationType);\n            \n            if (params.description) {\n                formData.append('description', params.description);\n            }\n            \n            if (params.status) {\n                formData.append('status', params.status);\n            }\n    \n            // Create a default image if none provided\n            if (!params.image) {\n                // Create a small transparent PNG as placeholder\n                const transparentPixel = new Uint8Array([\n                    0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A,\n                    0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,\n                    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,\n                    0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0x15, 0xC4,\n                    0x89, 0x00, 0x00, 0x00, 0x0A, 0x49, 0x44, 0x41,\n                    0x54, 0x78, 0x9C, 0x63, 0x00, 0x00, 0x00, 0x02,\n                    0x00, 0x01, 0xE5, 0x27, 0xDE, 0xFC, 0x00, 0x00,\n                    0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42,\n                    0x60, 0x82\n                ]);\n                const defaultImage = new Blob([transparentPixel], { type: 'image/png' });\n                formData.append('image', defaultImage, 'placeholder.png');\n            } else {\n                formData.append('image', params.image, 'image.jpg');\n            }\n    \n            const response = await fetch(`${BASE_URL}/campaigns`, {\n                method: 'POST',\n                headers: {\n                    ...baseHeaders,\n                    // Note: Content-Type is automatically set by fetch when using FormData\n                },\n                body: formData\n            });\n            \n            const result = await handleApiResponse(response, 'createCampaign');\n            return result as CampaignResponse;\n        } catch (error) {\n            if (!(error instanceof RaiinmakerApiError)) {\n                const err = error as Error;\n                throw new RaiinmakerApiError(`${logPrefix} Error creating campaign: ${err.message}`, {\n                    endpoint: 'createCampaign',\n                    details: error\n                });\n            }\n            throw error;\n        }\n    };\n    \n    /**\n     * Updates an existing campaign\n     */\n    const updateCampaign = async (campaignId: string, params: UpdateCampaignParams): Promise<CampaignResponse> => {\n        if (!campaignId) {\n            throw new RaiinmakerApiError('Campaign ID is required');\n        }\n        \n        try {\n            elizaLogger.info(`${logPrefix} Updating campaign: ${campaignId}`);\n            const formData = createFormData(params);\n    \n            const response = await fetch(`${BASE_URL}/campaigns/${campaignId}`, {\n                method: 'PUT',\n                headers: {\n                    ...baseHeaders,\n                    // Content-Type is set automatically for FormData\n                },\n                body: formData\n            });\n            \n            const result = await handleApiResponse(response, 'updateCampaign');\n            return result as CampaignResponse;\n        } catch (error) {\n            if (!(error instanceof RaiinmakerApiError)) {\n                const err = error as Error;\n                throw new RaiinmakerApiError(`${logPrefix} Error updating campaign: ${err.message}`, {\n                    endpoint: 'updateCampaign',\n                    details: { campaignId, error }\n                });\n            }\n            throw error;\n        }\n    };\n    \n    /**\n     * Gets a campaign by ID\n     */\n    const getCampaign = async (campaignId: string): Promise<CampaignResponse> => {\n        if (!campaignId) {\n            throw new RaiinmakerApiError('Campaign ID is required');\n        }\n        \n        try {\n            elizaLogger.info(`${logPrefix} Fetching campaign: ${campaignId}`);\n            \n            const response = await fetch(`${BASE_URL}/campaigns/${campaignId}`, {\n                method: 'GET',\n                headers: baseHeaders\n            });\n            \n            const result = await handleApiResponse(response, 'getCampaign');\n            return result as CampaignResponse;\n        } catch (error) {\n            if (!(error instanceof RaiinmakerApiError)) {\n                const err = error as Error;\n                throw new RaiinmakerApiError(`${logPrefix} Error getting campaign: ${err.message}`, {\n                    endpoint: 'getCampaign',\n                    details: { campaignId, error }\n                });\n            }\n            throw error;\n        }\n    };\n    \n    /**\n     * Creates a task to ask users if the content is appropriate for an AI agent to post\n     */\n    const createGenerationVerificationTask = async (content: string, options: {\n        campaignId?: string;\n        name?: string;\n        consensusVotes?: number;\n        question?: string;\n    } = {}): Promise<CreateTaskResponse> => {\n        if (!content) {\n            throw new RaiinmakerApiError('Content to verify is required');\n        }\n        \n        try {\n            elizaLogger.info(`${logPrefix} Creating verification task for content: ${content.substring(0, 50)}...`);\n            \n            // Define the task data with reasonable defaults\n            const taskData: {\n                name: string;\n                type: string;\n                humanRequired: boolean;\n                consensusVotes: number;\n                reputation: string;\n                question: string;\n                subject: string;\n                campaignId?: string;\n            } = {\n                name: options.name || \"Content Verification Task\",\n                type: \"BOOL\",  // Boolean verification is most appropriate for content approval\n                humanRequired: true,\n                consensusVotes: options.consensusVotes || 3,\n                reputation: \"NORMAL\",  // Allow any validator to participate\n                question: options.question || \"Is this content appropriate for an AI agent to post?\",\n                subject: content  // The content to verify\n            };\n            \n            // Add campaignId if it exists\n            if (options.campaignId) {\n                taskData.campaignId = options.campaignId;\n            }\n    \n            elizaLogger.debug(`${logPrefix} Sending verification task to Raiinmaker API:`, JSON.stringify(taskData, null, 2));\n    \n            // Make the API request with detailed error handling\n            try {\n                const response = await fetch(`${BASE_URL}/task`, {\n                    method: 'POST',\n                    headers: {\n                        ...baseHeaders,\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify(taskData)\n                });\n                \n                // Log the status code for debugging\n                elizaLogger.debug(`${logPrefix} Raiinmaker API response status: ${response.status} ${response.statusText}`);\n                \n                // Get the response body as text first for debugging\n                const responseText = await response.text();\n                elizaLogger.debug(`${logPrefix} Raiinmaker API response body: ${responseText}`);\n                \n                // Parse the response if possible\n                let responseData;\n                try {\n                    responseData = JSON.parse(responseText);\n                } catch (parseError) {\n                    throw new RaiinmakerApiError(`Failed to parse API response: ${responseText}`, {\n                        endpoint: 'createGenerationVerificationTask',\n                        details: parseError\n                    });\n                }\n                \n                // Handle unsuccessful responses\n                if (!response.ok) {\n                    throw new RaiinmakerApiError(`Task creation failed with status ${response.status}: ${JSON.stringify(responseData)}`, {\n                        status: response.status,\n                        endpoint: 'createGenerationVerificationTask',\n                        details: responseData\n                    });\n                }\n                \n                // Validate the response structure\n                if (!responseData.success || !responseData.data || !responseData.data.id) {\n                    throw new RaiinmakerApiError(`Invalid response format: ${JSON.stringify(responseData)}`, {\n                        endpoint: 'createGenerationVerificationTask',\n                        details: responseData\n                    });\n                }\n                \n                elizaLogger.success(`${logPrefix} Successfully created verification task with ID: ${responseData.data.id}`);\n                return responseData as CreateTaskResponse;\n                \n            } catch (error) {\n                if (error instanceof RaiinmakerApiError) {\n                    throw error;\n                }\n                \n                // Handle network or other errors\n                const err = error as Error;\n                throw new RaiinmakerApiError(`API request failed: ${err.message}`, {\n                    endpoint: 'createGenerationVerificationTask',\n                    details: error\n                });\n            }\n        } catch (error) {\n            elizaLogger.error(`${logPrefix} Error creating verification task: ${error instanceof Error ? error.message : String(error)}`);\n            \n            if (error instanceof RaiinmakerApiError) {\n                elizaLogger.error(`${logPrefix} API details: ${JSON.stringify({\n                    status: error.status,\n                    endpoint: error.endpoint,\n                    details: error.details\n                }, null, 2)}`);\n            }\n            \n            throw error;\n        }\n    };\n\n    // Return the service functions\n    return {\n        getAllTasks,\n        getTaskById,\n        getDataVerification,\n        createCampaign,\n        updateCampaign,\n        getCampaign,\n        createGenerationVerificationTask\n    };\n};\n\n/**\n * Gets agent validation data\n */\nasync function getAgentValidation(\n    apiKey: string,\n    appId: string,\n    data: string,\n    attempts = 0,\n    maxAttempts = 5\n): Promise<AgentValidationResponse> {\n    if (!apiKey || !appId) {\n        throw new Error(\"API key and App ID are required\");\n    }\n\n    try {\n        // Use the correct endpoint\n        const url = `${BASE_URL}/validate`;\n\n        // Log the request for debugging\n        elizaLogger.debug(`Validating data with Raiinmaker API: ${url}`);\n\n        // Make the API call\n        const response = await fetch(url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json',\n                'appId': appId,\n                'appSecret': apiKey\n            },\n            body: JSON.stringify({\n                content: data,\n                type: \"text\"\n            })\n        });\n\n        // Check if the response is successful\n        if (!response.ok) {\n            const responseText = await response.text();\n            elizaLogger.error(`Error response: ${responseText}`);\n            \n            // Retry logic\n            if (attempts < maxAttempts) {\n                await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempts) * 1000));\n                return getAgentValidation(apiKey, appId, data, attempts + 1, maxAttempts);\n            }\n            \n            throw new Error(`Request failed with status ${response.status}: ${responseText}`);\n        }\n\n        // Parse the successful response\n        const result = await response.json();\n        elizaLogger.debug(\"Validation response:\", result);\n        \n        // Return a properly formatted response\n        return {\n            classification: result.classification || \"unknown\",\n            message: result.message || \"No message provided\",\n            date: new Date().toLocaleDateString(),\n            time: new Date().toLocaleTimeString(),\n            url: \"https://seed.raiinmaker.com\"\n        };\n    } catch (error) {\n        elizaLogger.error(\"Error during data verification:\", error);\n        throw error;\n    }\n}","import { IAgentRuntime, elizaLogger } from \"@elizaos/core\";\nimport { z } from \"zod\";\n\n// Add environment setting to schema with OpenAI integration\nexport const raiinmakerEnvironment = z.object({\n    RAIINMAKER_APP_ID: z.string().min(1, \"RAIINMAKER_APP_ID is required\"),\n    RAIINMAKER_API_KEY: z.string().min(1, \"RAIINMAKER_API_KEY is required\"),\n    RAIINMAKER_ENVIRONMENT: z.enum([\"development\", \"staging\", \"production\"]).default(\"development\"),\n    OPENAI_API_KEY: z.string().optional(), // Optional to allow fallback to human verification\n    ENABLE_PRE_VERIFICATION: z.boolean().optional().default(true)\n});\n\nexport type raiinmakerConfig = z.infer<typeof raiinmakerEnvironment>;\n\nexport async function validateRaiinmakerConfig(\n    runtime: IAgentRuntime, \n    options: { allowMissing?: boolean, silent?: boolean } = {}\n): Promise<raiinmakerConfig> {\n    try {\n        const config = {\n            RAIINMAKER_API_KEY: runtime.getSetting(\"RAIINMAKER_API_KEY\") || process.env.RAIINMAKER_API_KEY,\n            RAIINMAKER_APP_ID: runtime.getSetting(\"RAIINMAKER_APP_ID\") || process.env.RAIINMAKER_APP_ID,\n            RAIINMAKER_ENVIRONMENT: runtime.getSetting(\"RAIINMAKER_ENVIRONMENT\") || \n                                   process.env.RAIINMAKER_ENVIRONMENT || \n                                   \"development\",\n            OPENAI_API_KEY: runtime.getSetting(\"OPENAI_API_KEY\") || process.env.OPENAI_API_KEY,\n            ENABLE_PRE_VERIFICATION: parseBoolean(runtime.getSetting(\"ENABLE_PRE_VERIFICATION\") || \n                                              process.env.ENABLE_PRE_VERIFICATION || \n                                              \"true\")\n        };\n\n        const result = raiinmakerEnvironment.safeParse(config);\n        \n        if (!result.success) {\n            // Format the error message with proper template string\n            const errorMessages = result.error.errors.map(\n                (err) => `${err.path.join(\".\")}: ${err.message}`\n            ).join(\"\\n\");\n            \n            const errorMessage = `Raiinmaker API configuration failed:\\n${errorMessages}`;\n            \n            if (!options.silent) {\n                elizaLogger.error(errorMessage);\n            }\n            \n            throw new Error(errorMessage);\n        }\n        \n        return result.data;\n    } catch (error) {\n        if (!options.silent) {\n            elizaLogger.error(\"Error validating Raiinmaker config:\", error);\n        }\n        \n        if (error instanceof z.ZodError) {\n            const errorMessages = error.errors.map(\n                (err) => `${err.path.join(\".\")}: ${err.message}`\n            ).join(\"\\n\");\n            \n            throw new Error(`Raiinmaker API configuration failed:\\n${errorMessages}`);\n        }\n        throw error;\n    }\n}\n\n// Add a utility function to check if we're in development mode\nexport async function isDevelopmentEnvironment(runtime: IAgentRuntime): Promise<boolean> {\n    try {\n        const config = await validateRaiinmakerConfig(runtime, { silent: true });\n        return config.RAIINMAKER_ENVIRONMENT === \"development\";\n    } catch (error) {\n        // Default to false (more restrictive) if we can't determine environment\n        return false;\n    }\n}\n\n// Create a function to check if an action is allowed in the current environment\nexport async function isActionAllowedInEnvironment(\n    runtime: IAgentRuntime,\n    actionName: string,\n    options: { developmentOnly?: boolean, allowedEnvironments?: string[] } = {}\n): Promise<boolean> {\n    try {\n        const config = await validateRaiinmakerConfig(runtime, { silent: true });\n        const currentEnv = config.RAIINMAKER_ENVIRONMENT;\n        \n        // If action is development-only\n        if (options.developmentOnly && currentEnv !== \"development\") {\n            elizaLogger.warn(`Action ${actionName} is only available in development environment`);\n            return false;\n        }\n        \n        // If action is restricted to specific environments\n        if (options.allowedEnvironments && !options.allowedEnvironments.includes(currentEnv)) {\n            elizaLogger.warn(`Action ${actionName} is not available in ${currentEnv} environment`);\n            return false;\n        }\n        \n        return true;\n    } catch (error) {\n        elizaLogger.error(`Error checking environment permissions for ${actionName}:`, error);\n        // Default to false (more restrictive) if we can't determine environment\n        return false;\n    }\n}\n\n// Add a helper utility to check if pre-verification is enabled\nexport async function isPreVerificationEnabled(runtime: IAgentRuntime): Promise<boolean> {\n    try {\n        const config = await validateRaiinmakerConfig(runtime, { silent: true });\n        \n        // If OpenAI API key is missing, pre-verification can't run\n        if (!config.OPENAI_API_KEY) {\n            return false;\n        }\n        \n        return config.ENABLE_PRE_VERIFICATION === true;\n    } catch (error) {\n        // Default to false if we can't determine\n        return false;\n    }\n}\n\n// Helper function to parse boolean values from string environment variables\nfunction parseBoolean(value: string | undefined | null): boolean {\n    if (!value) return true; // Default to true\n    \n    const lowercased = value.toLowerCase();\n    return !['false', '0', 'no', 'off', 'disabled'].includes(lowercased);\n}","import { ActionExample } from \"@elizaos/core\";\n\n/**\n * Examples for GET_RAIIN_QUEST_STATUS action\n * \n * These examples show how the agent can retrieve quest status information\n * from the Raiinmaker platform, including filtering by date, status and type.\n */\nexport const getQuestStatusExample: ActionExample[][] = [\n    // Basic quest status request\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"What is the status of my raiinmaker quest?\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"Let me take a look at that quest for you.\",\n                action: \"GET_RAIIN_QUEST_STATUS\",\n            },\n        }\n    ],\n    // Simple alternative phrasing\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"Tell me about my quest.\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"Let me check the Raiinmaker app for you.\",\n                action: \"GET_RAIIN_QUEST_STATUS\",\n            },\n        }\n    ],\n    // Request with time filter\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"Show me my quests from this week.\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"I'll retrieve your quests from this week.\",\n                action: \"GET_RAIIN_QUEST_STATUS\",\n            },\n        }\n    ],\n    // Request with status filter\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"What quests do I have that are still pending?\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"Let me check your pending quests in the Raiinmaker system.\",\n                action: \"GET_RAIIN_QUEST_STATUS\",\n            },\n        }\n    ],\n    // Request with type filter\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"Show me my boolean verification tasks.\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"I'll look up your boolean verification tasks.\",\n                action: \"GET_RAIIN_QUEST_STATUS\",\n            },\n        }\n    ],\n    // Combined filters\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"What completed verification tasks did I have this month?\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"I'll find your completed verification tasks from this month.\",\n                action: \"GET_RAIIN_QUEST_STATUS\",\n            },\n        }\n    ]\n];\n\n/**\n * Examples for GET_RAIIN_DATA_VERIFICATION action\n * \n * These examples show how the agent can verify data through\n * the Raiinmaker validation service with various data formats.\n */\nexport const getDataVerificationExample: ActionExample[][] = [\n    // Generic data verification\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"Can you verify this data for me? The sky is blue.\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"Let me verify that data for you.\",\n                action: \"GET_RAIIN_DATA_VERIFICATION\",\n            },\n        }\n    ],\n    // URL verification\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"Is this URL valid? https://example.com/resource\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"I'll verify that URL through the Raiinmaker service.\",\n                action: \"GET_RAIIN_DATA_VERIFICATION\",\n            },\n        }\n    ],\n    // Statement verification\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"Can you verify if this statement is accurate? 'The Earth completes one rotation every 24 hours.'\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"I'll validate that statement for accuracy.\",\n                action: \"GET_RAIIN_DATA_VERIFICATION\",\n            },\n        }\n    ],\n    // Data with context\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"I need to verify this scientific claim in my article: 'Water boils at 100 degrees Celsius at sea level.'\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"I'll verify that scientific claim through our validation service.\",\n                action: \"GET_RAIIN_DATA_VERIFICATION\",\n            },\n        }\n    ]\n];\n\n/**\n * Examples for VERIFY_GENERATION_CONTENT action\n * \n * These examples show how the agent can verify if content is appropriate\n * for posting through the Raiinmaker human validation system.\n */\nexport const verifyGenerationContentExamples: ActionExample[][] = [\n    // Tweet verification with single quotes\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"Can you verify if this tweet is appropriate? 'Just tried the new AI feature and it's incredible! #AIrevolution'\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"I'll verify if that tweet is appropriate for posting.\",\n                action: \"VERIFY_GENERATION_CONTENT\",\n            },\n        }\n    ],\n    // Post verification with quoted content\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"Is this a good post to share: 'Check out our latest product update that improves performance by 30%!'\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"Let me check if this content is appropriate for posting.\",\n                action: \"VERIFY_GENERATION_CONTENT\",\n            },\n        }\n    ],\n    // Content verification with direct content\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"Please verify this content: Join our exclusive community to get insider tips and secret strategies.\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"I'll submit this content for verification to see if it's appropriate.\",\n                action: \"VERIFY_GENERATION_CONTENT\",\n            },\n        }\n    ],\n    // Verification with specific context\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"Is this social media post appropriate for a corporate account? 'We're excited to announce our partnership with @CompanyX to revolutionize the industry! #Partnership #Innovation'\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"I'll have this corporate social media post verified for appropriateness.\",\n                action: \"VERIFY_GENERATION_CONTENT\",\n            },\n        }\n    ],\n    // Multiple pieces of content\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"I have two tweets I'd like to verify. First one: 'Our new product launches tomorrow! #Excited'\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"I'll verify the first tweet for you.\",\n                action: \"VERIFY_GENERATION_CONTENT\",\n            },\n        }\n    ]\n];\n\n/**\n * Examples for CHECK_VERIFICATION_STATUS action\n * \n * These examples show how the agent can check the status of content verification\n * tasks that were previously submitted.\n */\nexport const checkVerificationStatusExamples: ActionExample[][] = [\n    // Check with explicit task ID\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"What's the status of my content verification with task ID abc123?\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"Let me check the status of your verification task.\",\n                action: \"CHECK_VERIFICATION_STATUS\",\n            },\n        }\n    ],\n    // Alternative phrasing with ID\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"Has my tweet been verified yet? The task ID is xyz789.\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"I'll check if your tweet has been verified.\",\n                action: \"CHECK_VERIFICATION_STATUS\",\n            },\n        }\n    ],\n    // Check with embedded UUID format\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"Can you check verification status for a2ba2d85-d95d-47ba-af8f-79826df2ddf1?\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"I'll check the status of that verification task for you.\",\n                action: \"CHECK_VERIFICATION_STATUS\",\n            },\n        }\n    ],\n    // Follow-up on previous verification\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"Did that tweet I asked about earlier get approved?\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"I'll check if your previous verification task has been completed.\",\n                action: \"CHECK_VERIFICATION_STATUS\",\n            },\n        }\n    ],\n    // Status check with vote interest\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"How many votes has my verification task received? The ID is task-123.\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"Let me check how many votes your verification task has received.\",\n                action: \"CHECK_VERIFICATION_STATUS\",\n            },\n        }\n    ]\n];\n\n\nexport const setupRaiinCredentialsExamples: ActionExample[][] = [\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"My App ID is abc123 and my API Key is xyz789\"\n            }\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"Setting up your Raiinmaker credentials...\",\n                action: \"SETUP_RAIIN_CREDENTIALS\"\n            }\n        }\n    ],\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"My new appId is updated it is ab123cd my new API key is rmk-1hat553shhhfh\"\n            }\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"Setting up your Raiinmaker credentials...\",\n                action: \"SETUP_RAIIN_CREDENTIALS\"\n            }\n        }\n    ]\n];\n\nexport const allActionExamples = {\n    getQuestStatusExample,\n    getDataVerificationExample,\n    verifyGenerationContentExamples,\n    checkVerificationStatusExamples,\n    setupRaiinCredentialsExamples\n};","import { \n    Action,\n    IAgentRuntime,\n    Memory,\n    State,\n    ActionExample,\n    HandlerCallback,\n    elizaLogger,\n    Handler\n} from \"@elizaos/core\";\nimport { createRaiinmakerService } from \"../services/raiinmakerService\";\nimport { validateRaiinmakerConfig } from \"../environment\";\nimport { getDataVerificationExample } from \"../examples\";\n\nexport const getDataVerification: Action = {\n    name: \"GET_RAIIN_DATA_VERIFICATION\",\n    similes: [\n        \"VERIFY_DATA\",\n        \"CHECK_DATA\",\n        \"GET_RAIIN_VERIFICATION_DATA\",\n        \"GET_RAIIN_VERIFICATION\"\n    ],\n    description: \"Verifies data through the Raiinmaker validation service\",\n    examples: getDataVerificationExample as ActionExample[][],\n    \n    validate: async (runtime: IAgentRuntime, message: Memory) => {\n        try {\n            await validateRaiinmakerConfig(runtime);\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Validation failed:\", error);\n            return false;\n        }\n    },\n\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: { [key: string]: unknown; },\n        callback: HandlerCallback\n    ) => {\n        try {\n            // Get global credentials\n            const config = await validateRaiinmakerConfig(runtime);\n            if (!config) {\n                callback({\n                    text: `Raiinmaker API configuration is not properly set up.`,\n                    proceed: false\n                });\n                return false;\n            }\n            \n            // Create the service with global credentials\n            const raiinService = createRaiinmakerService(\n                config.RAIINMAKER_API_KEY,\n                config.RAIINMAKER_APP_ID\n            );\n\n            // Get data verification\n            const verificationResult = await raiinService.getDataVerification(\n                message.content.text\n            );\n            elizaLogger.success(\"Successfully retrieved data verification\");\n    \n            const {classification, message: verificationMessage, date, time} = verificationResult;\n            \n            // Format response based on classification\n            let responseText = \"\";\n            let proceed = false;\n            \n            switch(classification.toLowerCase()) {\n                case \"approved\":\n                case \"valid\":\n                case \"success\":\n                    responseText = `✅ The content has been verified and approved.\\n\\nVerification details:\\n- Status: ${classification}\\n- Message: ${verificationMessage}\\n- Verified on: ${date} at ${time}`;\n                    proceed = true;\n                    break;\n                    \n                case \"pending\":\n                case \"processing\":\n                    responseText = `⏳ Your content is still being processed.\\n\\nVerification details:\\n- Status: ${classification}\\n- Message: ${verificationMessage}\\n- Submitted on: ${date} at ${time}\\n\\nPlease check back later for the final result.`;\n                    proceed = false;\n                    break;\n                    \n                case \"rejected\":\n                case \"invalid\":\n                case \"failed\":\n                    responseText = `❌ The content verification was not successful.\\n\\nVerification details:\\n- Status: ${classification}\\n- Reason: ${verificationMessage}\\n- Verified on: ${date} at ${time}\\n\\nPlease review and modify your content according to the feedback.`;\n                    proceed = false;\n                    break;\n                    \n                default:\n                    responseText = `ℹ️ Verification result received.\\n\\nVerification details:\\n- Status: ${classification}\\n- Message: ${verificationMessage}\\n- Processed on: ${date} at ${time}`;\n                    proceed = false;\n            }\n            \n            callback({\n                text: responseText,\n                proceed\n            });\n            return proceed;\n        } catch (error) {\n            elizaLogger.error(\"Error in getDataVerification handler:\", error);\n            callback({\n                text: \"I apologize, but I'm having trouble verifying the data at the moment. Please try again later.\",\n                proceed: false\n            });\n            return false;\n        }\n    }\n} as Action;","// src/actions/verifyGenerationContent.ts\nimport { \n    Action,\n    IAgentRuntime,\n    Memory,\n    State,\n    HandlerCallback,\n    elizaLogger,\n    ActionExample\n} from \"@elizaos/core\";\nimport { createRaiinmakerService, RaiinmakerApiError } from \"../services/raiinmakerService\";\nimport { preVerifyContent } from \"../services/contentPreVerificationService\";\nimport { extractVerifiableContent } from \"../utils/contentExtractor\";\nimport { ensureUUID } from \"../utils/uuidHelpers\";\nimport { z } from \"zod\";\nimport { validateRaiinmakerConfig } from \"../environment\";\n\n// Define options schema for the action\nconst verifyGenerationContentOptionsSchema = z.object({\n    content: z.string().min(1, \"Content is required\").optional(),\n    consensusVotes: z.number().min(1).optional(),\n    question: z.string().optional(),\n    roomId: z.string().optional(),\n    name: z.string().optional(),\n    // Add option to skip pre-verification for testing/comparison\n    skipPreVerification: z.boolean().optional(),\n}).optional();\n\n// Action examples (existing code)\nconst verifyGenerationContentExamples: ActionExample[][] = [\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"Please verify this content: \\\"Hello world, this is a test tweet!\\\"\"\n            }\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"I'll submit that content for verification.\",\n                action: \"VERIFY_GENERATION_CONTENT\"\n            }\n        }\n    ]\n];\n\nexport const verifyGenerationContent: Action = {\n    name: \"VERIFY_GENERATION_CONTENT\",\n    similes: [\n        \"CHECK_CONTENT\",\n        \"VALIDATE_TWEET\",\n        \"VERIFY_TWEET\",\n        \"VERIFY_POST\"\n    ],\n    description: \"Submits content to the Raiinmaker app for verification to determine if it's appropriate for posting\",\n    examples: verifyGenerationContentExamples,\n    \n    validate: async (runtime: IAgentRuntime, message: Memory) => {\n        try {\n            // Validate that the environment has the required credentials\n            await validateRaiinmakerConfig(runtime);\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Validation failed:\", error);\n            return false;\n        }\n    },\n\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state?: State,\n        options?: { [key: string]: unknown; },\n        callback?: HandlerCallback\n    ) => {\n        try {\n            // Parse and validate options\n            const parsedOptions = verifyGenerationContentOptionsSchema.parse(options);\n            \n            // Get credentials from environment\n            const config = await validateRaiinmakerConfig(runtime);\n            \n            if (!config) {\n                if (callback) {\n                    callback({\n                        text: `\nRaiinmaker API configuration is not properly set up. \n\nPlease ensure the following environment variables are set:\n- RAIINMAKER_APP_ID: Your Raiinmaker application ID\n- RAIINMAKER_API_KEY: Your Raiinmaker API key\n                        `\n                    });\n                }\n                return false;\n            }\n\n            // Extract content from message or options\n            let contentToVerify: string;\n            if (parsedOptions && parsedOptions.content) {\n                contentToVerify = parsedOptions.content;\n            } else {\n                contentToVerify = extractVerifiableContent(message.content.text);\n            }\n            \n            // Verify we have content to check\n            if (!contentToVerify || contentToVerify.trim().length === 0) {\n                if (callback) {\n                    callback({\n                        text: \"I couldn't identify any content to verify. Please provide some content by quoting it or clearly indicating what you'd like me to verify.\"\n                    });\n                }\n                return false;\n            }\n            \n            const userId = ensureUUID(message.userId);\n            elizaLogger.info(`Processing verification for content from user ${userId}`);\n\n            // NEW: Pre-verification step with OpenAI\n            let preVerificationResult: Awaited<ReturnType<typeof preVerifyContent>> | undefined;\n            \n            if (!parsedOptions?.skipPreVerification) {\n                elizaLogger.info(\"Running content pre-verification check\");\n                \n                // Get any custom checklist from character settings if available\n                let customChecklist: string[] | undefined;\n                \n                // Safely access the contentChecklist from settings using type assertion\n                const settings = runtime.character?.settings as Record<string, any>;\n                if (settings && Array.isArray(settings.contentChecklist)) {\n                    customChecklist = settings.contentChecklist;\n                    elizaLogger.debug(\"Using custom content checklist from character settings\");\n                }\n                \n                preVerificationResult = await preVerifyContent(\n                    runtime,\n                    contentToVerify,\n                    customChecklist\n                );\n                \n                // If content passes pre-verification, return success and skip human verification\n                if (preVerificationResult.passes) {\n                    elizaLogger.info(\"Content passed pre-verification checks, skipping human verification\");\n                    \n                    // Create a deterministic task ID for auto-verified content\n                    const autoVerifiedTaskId = ensureUUID(`auto-verified-${Date.now()}`);\n                    \n                    if (callback) {\n                        callback({\n                            text: `\nI've analyzed your content using AI verification and it looks good to go!\n\n📋 Content: \"${contentToVerify.substring(0, 100)}${contentToVerify.length > 100 ? '...' : ''}\"\n\n✅ All guidelines passed\n• Content is appropriate for posting\n• No policy violations found\n\nThe content has been approved automatically. No human verification was needed.\n                            `,\n                            status: \"approved\",\n                            skipHumanVerification: true,\n                            // Add these fields for Twitter client compatibility\n                            taskId: autoVerifiedTaskId,\n                            verificationResult: {\n                                taskId: autoVerifiedTaskId,\n                                status: \"completed\",\n                                answer: true,\n                                question: \"Is this content appropriate for posting?\",\n                                subject: contentToVerify,\n                                votesReceived: 0,\n                                votesRequired: 0,\n                                votesYes: 0,\n                                votesNo: 0,\n                                formattedText: `✅ Content Verification - The verification is complete. The content was approved automatically by AI.`\n                            }\n                        });\n                    }\n                    \n                    // Create a memory to track this auto-approved verification\n                    await runtime.messageManager.createMemory({\n                        id: ensureUUID(`verification-auto-approved-${Date.now()}`),\n                        userId: userId,\n                        agentId: ensureUUID(runtime.agentId),\n                        content: { \n                            text: `Content auto-approved by AI verification: \"${contentToVerify.substring(0, 50)}...\"`,\n                            metadata: {\n                                taskType: \"contentAutoApproved\",\n                                taskId: autoVerifiedTaskId,\n                                content: contentToVerify,\n                                timestamp: Date.now()\n                            }\n                        },\n                        roomId: ensureUUID(parsedOptions?.roomId || message.roomId),\n                        createdAt: Date.now()\n                    });\n                    \n                    return true;\n                }\n                \n                elizaLogger.info(`Content failed pre-verification checks: ${preVerificationResult.failedChecks.join(', ')}`);\n                elizaLogger.info(\"Content failed pre-verification, proceeding to human verification\");\n            }\n            \n            // Only continue with Raiinmaker human verification if pre-verification failed or was skipped\n            if (parsedOptions?.skipPreVerification || (preVerificationResult && !preVerificationResult.passes)) {\n                const raiinService = createRaiinmakerService(\n                    config.RAIINMAKER_API_KEY,\n                    config.RAIINMAKER_APP_ID\n                );\n\n                // Create verification task\n                const taskOptions = {\n                    name: parsedOptions?.name || \"Content Verification\",\n                    consensusVotes: parsedOptions?.consensusVotes || 3,\n                    question: parsedOptions?.question || \"Is this content appropriate for an AI agent to post?\"\n                };\n\n                const verificationResult = await raiinService.createGenerationVerificationTask(\n                    contentToVerify,\n                    taskOptions\n                );\n\n                if (!verificationResult || !verificationResult.data || !verificationResult.data.id) {\n                    elizaLogger.error(\"Failed to create verification task: Invalid response from Raiinmaker service\");\n                    if (callback) {\n                        callback({\n                            text: \"I apologize, but I wasn't able to submit the content for verification. There might be an issue with the verification service.\"\n                        });\n                    }\n                    return false;\n                }\n\n                // Get the task ID\n                const taskId = verificationResult.data.id;\n                \n                // Use the roomId provided in options, message roomId, or create a consistent one\n                const roomId = ensureUUID(parsedOptions?.roomId || message.roomId);\n                \n                // Create a memory to track this verification\n                await runtime.messageManager.createMemory({\n                    id: ensureUUID(`verification-${taskId}`),\n                    userId: userId,\n                    agentId: ensureUUID(runtime.agentId),\n                    content: { \n                        text: `Verification task created for \"${contentToVerify.substring(0, 50)}...\" with ID: ${taskId}`,\n                        metadata: {\n                            taskType: \"contentVerification\",\n                            taskId: taskId,\n                            content: contentToVerify,\n                            timestamp: Date.now()\n                        }\n                    },\n                    roomId: roomId,\n                    createdAt: Date.now()\n                });\n                \n                if (callback) {\n                    callback({\n                        text: `\nI've submitted your content for verification through the Raiinmaker network.\n\n📋 Content: \"${contentToVerify.substring(0, 100)}${contentToVerify.length > 100 ? '...' : ''}\"\n\n🔍 Task ID: ${taskId}\n\nThe content will be reviewed by human validators in the Raiinmaker network. They'll determine if the content is appropriate for posting based on community guidelines.\n\nYou can check the status of this verification later by asking me about this task using the Task ID.\n\n⏳ The verification process typically takes a few minutes to a few hours, depending on validator availability.\n                        `,\n                        taskId: taskId,\n                        status: \"pending\"\n                    });\n                }\n            }\n            \n            return true;\n        } catch (error) {\n            if (error instanceof RaiinmakerApiError) {\n                elizaLogger.error(`Raiinmaker API Error: ${error.message}`, error);\n                callback?.({\n                    text: `There was an error with the Raiinmaker API: ${error.message}\\n\\nThis might indicate an issue with your API credentials or the API service.`\n                });\n            } else {\n                elizaLogger.error(\"Error in verifyGenerationContent handler:\", error);\n                callback?.({\n                    text: \"I apologize, but I'm having trouble submitting the content for verification at the moment. Please try again later.\"\n                });\n            }\n            return false;\n        }\n    }\n};","import { elizaLogger, IAgentRuntime } from \"@elizaos/core\";\nimport { isPreVerificationEnabled } from \"../environment\";\n\ninterface PreVerificationResult {\n  passes: boolean;\n  failedChecks: string[];\n  suggestedFix?: string;\n}\n\n/**\n * Sends content to OpenAI to check against content guidelines\n * before sending to human verification\n */\nexport async function preVerifyContent(\n  runtime: IAgentRuntime,\n  content: string,\n  checklistItems: string[] = DEFAULT_CHECKLIST\n): Promise<PreVerificationResult> {\n  try {\n    // First, check if pre-verification is enabled and OpenAI API key is available\n    const enabled = await isPreVerificationEnabled(runtime);\n    \n    if (!enabled) {\n      elizaLogger.info(\"Content pre-verification is disabled or OpenAI API key not configured, skipping check\");\n      return { passes: true, failedChecks: [] };\n    }\n    \n    // Get the API key\n    const apiKey = runtime.getSetting(\"OPENAI_API_KEY\") || process.env.OPENAI_API_KEY;\n    \n    if (!apiKey) {\n      elizaLogger.warn(\"OpenAI API key not found, skipping pre-verification\");\n      return { passes: true, failedChecks: [] };\n    }\n    \n    // Define the prompt with clear instructions and expected format\n    const prompt = `\nYou are a content verification assistant. Your job is to check if the content below follows all the guidelines in the checklist.\nRespond in JSON format with \"passes\" (boolean), \"failedChecks\" (array of failed checks), and \"suggestedFix\" (string with proposed edits if any).\n\nCONTENT TO VERIFY:\n\"\"\"\n${content}\n\"\"\"\n\nCHECKLIST:\n${checklistItems.map((item, index) => `${index + 1}. ${item}`).join('\\n')}\n\nRESPOND ONLY WITH JSON:\n`;\n\n    // Using OpenAI API specifically for content pre-verification\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${apiKey}`\n      },\n      body: JSON.stringify({\n        model: \"gpt-3.5-turbo\", // Using a smaller model for efficiency and cost savings\n        messages: [{ role: \"user\", content: prompt }],\n        temperature: 0.1, // Low temperature for more consistent, rule-based checking\n        response_format: { type: \"json_object\" }\n      })\n    });\n\n    const result = await response.json();\n    \n    // Check for API errors\n    if (result.error) {\n      elizaLogger.error(`OpenAI API error: ${result.error.message}`);\n      throw new Error(`OpenAI API error: ${result.error.message}`);\n    }\n    \n    // Extract the JSON response from the LLM output\n    let verification: PreVerificationResult;\n    \n    try {\n      verification = JSON.parse(result.choices[0].message.content);\n    } catch (parseError) {\n      elizaLogger.error(\"Failed to parse OpenAI response:\", parseError);\n      elizaLogger.debug(\"Raw OpenAI response:\", result.choices[0].message.content);\n      throw new Error(\"Failed to parse verification result\");\n    }\n    \n    // Environment-specific logging\n    const isDev = runtime.getSetting(\"RAIINMAKER_ENVIRONMENT\") === \"development\";\n    if (isDev) {\n      elizaLogger.debug(\"OpenAI verification response:\", verification);\n    }\n    \n    // Log the result\n    elizaLogger.info(`Pre-verification result: ${verification.passes ? 'PASSED' : 'FAILED'}`);\n    if (!verification.passes) {\n      elizaLogger.info(`Failed checks: ${verification.failedChecks.join(', ')}`);\n    }\n    \n    return verification;\n    \n  } catch (error) {\n    elizaLogger.error(\"Error in content pre-verification:\", error);\n    // Default to passing if there's an error, so we fall back to human verification\n    return { passes: true, failedChecks: [] };\n  }\n}\n\n// Default checklist if none provided\nconst DEFAULT_CHECKLIST = [\n  \"Content does not contain hate speech or discriminatory language\",\n  \"Content is appropriate for the target audience\",\n  \"Content aligns with the agent's persona and purpose\",\n  \"Content does not contain unsafe advice or recommendations\",\n  \"Content follows platform guidelines for the intended social network\",\n  \"Content is free from profanity or explicit material\"\n];","\n/**\n * Extracts content to verify from a message\n * Uses various strategies to identify the content to be verified\n */\nexport function extractVerifiableContent(messageText: string): string {\n    // Try extracting quoted content first (most reliable)\n    const quotedSingleContent = messageText.match(/'([^']+)'/);\n    const quotedDoubleContent = messageText.match(/\"([^\"]+)\"/);\n    \n    if (quotedSingleContent && quotedSingleContent[1]) {\n      return quotedSingleContent[1];\n    }\n    \n    if (quotedDoubleContent && quotedDoubleContent[1]) {\n      return quotedDoubleContent[1];\n    }\n    \n    // Try to find content after common phrases\n    const commonPhrasePatterns = [\n      /(?:verify|check|validate|is\\s+this\\s+(?:appropriate|good))(?:\\s*this)?(?:\\s*content|tweet|post)?[:\\s-]+(.+)$/i,\n      /(?:is\\s+this\\s+(?:appropriate|good))[:\\s-]+(.+)$/i,\n      /(?:content|tweet|post)[:\\s-]+[\"']?([^\"']+)[\"']?$/i\n    ];\n    \n    for (const pattern of commonPhrasePatterns) {\n      const match = messageText.match(pattern);\n      if (match && match[1] && match[1].trim().length > 0) {\n        return match[1].trim();\n      }\n    }\n    \n    // If all strategies fail, use the full message but remove verification request phrases\n    const cleanedMessage = messageText\n      .replace(/(?:can you |please |could you )?(?:verify|check|validate|is this good|is this appropriate)(?:\\s+if|\\s+whether)?\\s*/i, '')\n      .replace(/(?:this |the |following |content |tweet |post |message )+/i, '')\n      .trim();\n    \n    return cleanedMessage;\n  }","import { v4 as uuidv4 } from 'uuid';\nimport { UUID } from '../types';\n\nexport function ensureUUID(id: string | undefined): UUID {\n    if (!id) {\n        return uuidv4() as UUID;\n    }\n    if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(id)) {\n        return id as UUID;\n    }\n    return uuidv4() as UUID;\n} ","// src/actions/checkVerificationStatus.ts\nimport { \n    Action,\n    IAgentRuntime,\n    Memory,\n    State,\n    HandlerCallback,\n    ActionExample,\n    elizaLogger\n} from \"@elizaos/core\";\nimport { createRaiinmakerService, RaiinmakerApiError } from \"../services/raiinmakerService\";\nimport { ensureUUID } from \"../utils/uuidHelpers\";\nimport { formatVerificationStatusResponse } from \"../utils/responseFormatter\";\nimport { z } from \"zod\";\nimport { validateRaiinmakerConfig } from \"../environment\";\n\n// Create example usage patterns for the action\nconst checkVerificationStatusExamples: ActionExample[][] = [\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"What's the status of my content verification with task ID abc123?\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"Let me check the status of your verification task.\",\n                action: \"CHECK_VERIFICATION_STATUS\",\n            },\n        }\n    ],\n    [\n        {\n            user: \"{{user1}}\",\n            content: {\n                text: \"Has my tweet been verified yet? The task ID is xyz789.\"\n            },\n        },\n        {\n            user: \"{{agent}}\",\n            content: {\n                text: \"I'll check if your tweet has been verified.\",\n                action: \"CHECK_VERIFICATION_STATUS\",\n            },\n        }\n    ],\n];\n\n// Define options schema for the action\nconst checkVerificationStatusOptionsSchema = z.object({\n    taskId: z.string().min(1, \"Task ID is required\").optional()\n}).optional();\n\nexport const checkVerificationStatus: Action = {\n    name: \"CHECK_VERIFICATION_STATUS\",\n    similes: [\n        \"GET_VERIFICATION_STATUS\",\n        \"CHECK_CONTENT_STATUS\",\n        \"VERIFY_STATUS\",\n        \"CHECK_TASK_STATUS\"\n    ],\n    description: \"Checks the status of a content verification task in the Raiinmaker app\",\n    examples: checkVerificationStatusExamples,\n    \n    validate: async (runtime: IAgentRuntime, message: Memory) => {\n        try {\n            // Validate that the environment has the required credentials\n            await validateRaiinmakerConfig(runtime);\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Validation failed:\", error);\n            return false;\n        }\n    },\n\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state?: State,\n        options?: { [key: string]: unknown; },\n        callback?: HandlerCallback\n    ) => {\n        try {\n            // Get credentials from environment\n            const config = await validateRaiinmakerConfig(runtime);\n            \n            if (!config) {\n                if (callback) {\n                    callback({\n                        text: `No Raiinmaker credentials available. Please set up credentials first.`\n                    });\n                }\n                return false;\n            }\n            \n            // Create the service with environment credentials\n            const raiinService = createRaiinmakerService(\n                config.RAIINMAKER_API_KEY,\n                config.RAIINMAKER_APP_ID\n            );\n\n            // Parse options using schema\n            const parsedOptions = checkVerificationStatusOptionsSchema.parse(options);\n\n            // Extract task ID from message or options\n            let taskId: string | undefined;\n\n            if (parsedOptions && parsedOptions.taskId) {\n                taskId = parsedOptions.taskId;\n            } else {\n                // Try multiple patterns to match task IDs\n                const messageText = message.content.text;\n                const idMatch = messageText.match(/task\\s*ID\\s*(?:is|:|=)?\\s*([a-zA-Z0-9-]+)/i) || \n                                messageText.match(/(?:check|verify|status|task)\\s*(?:for|of)?\\s*([a-f0-9-]{8,})/i) ||\n                                messageText.match(/([a-f0-9-]{8,})/i);\n                \n                if (idMatch && idMatch[1]) {\n                    taskId = idMatch[1];\n                } else {\n                    // Try to find a taskId in recent memory\n                    const recentMemories = await runtime.messageManager.getMemories({\n                        roomId: message.roomId,\n                        count: 10\n                    });\n                    \n                    // Look for task ID in recent messages (especially in metadata)\n                    for (const mem of recentMemories) {\n                        const metadata = mem?.content?.metadata;\n                        \n                        if (metadata && typeof metadata === 'object' && 'taskId' in metadata && typeof metadata.taskId === 'string') {\n                            taskId = metadata.taskId;\n                            break;\n                        } else if (mem.content?.text && typeof mem.content.text === 'string') {\n                            // Try to extract from text\n                            const textMatch = mem.content.text.match(/task\\s*ID\\s*(?:is|:|=)?\\s*([a-zA-Z0-9-]+)/i) || \n                                            mem.content.text.match(/([a-f0-9-]{8,})/i);\n                            \n                            if (textMatch && textMatch[1]) {\n                                taskId = textMatch[1];\n                                break;\n                            }\n                        }\n                    }\n                    \n                    // If we still don't have a taskId\n                    if (!taskId) {\n                        if (callback) {\n                            callback({\n                                text: \"I couldn't find a task ID in your message or our recent conversation. Please provide a valid task ID to check the verification status.\"\n                            });\n                        }\n                        return false;\n                    }\n                }\n            }\n\n            // Get task details\n            const taskResult = await raiinService.getTaskById(taskId as string);\n            \n            if (!taskResult.success || !taskResult.data) {\n                if (callback) {\n                    callback({\n                        text: `I couldn't find any verification task with ID ${taskId}. Please check the ID and try again.`,\n                        status: \"unknown\",\n                        answer: null\n                    });\n                }\n                return false;\n            }\n\n            const task = taskResult.data;\n            \n            // Parse raw values for logging\n            elizaLogger.info(`Raw task data: status=${task.status}, answer=${task.answer}`);\n            \n            // Use our new formatter to get a clean response\n            const formattedResponse = formatVerificationStatusResponse(task);\n            \n            // Log the formatted response for debugging\n            elizaLogger.info(`FINAL VERIFICATION STATUS: status=${formattedResponse.status}, answer=${formattedResponse.answer}`);\n            \n            // Status-specific detailed logging\n            if (formattedResponse.status === 'completed') {\n                elizaLogger.info(`Task ${taskId} ${formattedResponse.answer ? 'APPROVED' : 'REJECTED'}`);\n            } else if (formattedResponse.status === 'pending') {\n                elizaLogger.info(`PENDING: Task ${taskId} is still pending (status: ${formattedResponse.status})`);\n            }\n\n            if (callback) {\n                // Return a clean response with both human-readable text and structured data\n                callback({\n                    text: formattedResponse.formattedText || `Verification status: ${formattedResponse.status}`,\n                    verificationResult: formattedResponse, // Include the entire structured response\n                    status: formattedResponse.status,\n                    answer: formattedResponse.answer\n                });\n            }\n            \n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error in checkVerificationStatus handler:\", error);\n            callback?.({\n                text: \"I apologize, but I'm having trouble checking the verification status at the moment. Please try again later.\",\n                status: \"error\",\n                answer: null\n            });\n            return false;\n        }\n    }\n};","// src/utils/responseFormatter.ts\nimport { elizaLogger } from \"@elizaos/core\";\nimport { TaskWithVotes } from '../types';\n\n/**\n * A clean response object for verification status checks\n */\nexport interface VerificationStatusResponse {\n  taskId: string;\n  status: string;\n  answer: boolean | null;\n  question: string;\n  subject: string;\n  votesReceived: number;\n  votesRequired: number;\n  votesYes?: number;\n  votesNo?: number;\n  formattedText?: string; // Optional human-readable version\n}\n\n/**\n * Formats a task status response with sanitized output for both\n * machine parsing and human reading\n */\nexport function formatVerificationStatusResponse(task: TaskWithVotes): VerificationStatusResponse {\n  try {\n    // Extract core data with defaults for safety\n    const id = task.id || \"\";\n    const status = task.status || \"unknown\";\n    const question = task.question || \"\";\n    const subject = task.subject || \"\";\n    \n    // Parse the answer value safely\n    let parsedAnswer: boolean | null = null;\n    if (task.answer === 'true' || task.answer === 'yes') {\n      parsedAnswer = true;\n    } else if (task.answer === 'false' || task.answer === 'no') {\n      parsedAnswer = false;\n    }\n    \n    // Calculate vote statistics\n    const votes = task.votes || [];\n    const consensusVotes = task.consensusVotes || 0;\n    const yesVotes = votes.filter(v => v.answer === 'true').length;\n    const noVotes = votes.filter(v => v.answer === 'false').length;\n    \n    // Create simplified ID for display (first 8 chars)\n    const shortId = id.length > 8 ? `${id.substring(0, 8)}...` : id;\n    \n    // Create a status emoji for human-readable format\n    let statusEmoji = '⏳';\n    if (status === 'completed') {\n      statusEmoji = parsedAnswer === true ? '✅' : '❌';\n    }\n    \n    // Build a human-readable formatted text (without excessive newlines)\n    let statusText = '';\n    if (status === 'completed') {\n      statusText = `The verification is complete. The content was ${parsedAnswer ? 'approved' : 'rejected'}.`;\n    } else if (status === 'pending') {\n      statusText = `The verification is still in progress. ${votes.length} of ${consensusVotes} required votes collected.`;\n    } else {\n      statusText = `Status: ${status}`;\n    }\n    \n    // Construct a clean, well-formatted string for human consumption\n    const formattedText = `${statusEmoji} Content Verification (ID: ${shortId}) - ${statusText}`;\n    \n    // Return a clean, structured response object\n    return {\n      taskId: id,\n      status,\n      answer: parsedAnswer,\n      question,\n      subject,\n      votesReceived: votes.length,\n      votesRequired: consensusVotes,\n      votesYes: yesVotes,\n      votesNo: noVotes,\n      formattedText\n    };\n  } catch (error) {\n    elizaLogger.error(\"Error formatting verification response:\", error);\n    \n    // Return a minimal response in case of error\n    return {\n      taskId: task.id || \"unknown\",\n      status: \"error\",\n      answer: null,\n      question: \"\",\n      subject: \"\",\n      votesReceived: 0,\n      votesRequired: 0,\n      formattedText: \"Error formatting verification response\"\n    };\n  }\n}","import { Plugin } from \"@elizaos/core\";\nimport { getQuestStatus } from \"./actions/getQuestStatus\";\nimport { getDataVerification } from \"./actions/getDataVerification\";\nimport { verifyGenerationContent } from \"./actions/verifyGenerationContent\";\nimport { checkVerificationStatus } from \"./actions/checkVerificationStatus\";\nimport { createRaiinmakerService } from \"./services/raiinmakerService\";\nimport { \n    validateRaiinmakerConfig, \n    isDevelopmentEnvironment, \n    isActionAllowedInEnvironment,\n    isPreVerificationEnabled \n} from \"./environment\";\nimport { preVerifyContent } from \"./services/contentPreVerificationService\";\nimport { formatVerificationStatusResponse } from \"./utils/responseFormatter\";\n\nexport const raiinmakerPlugin: Plugin = {\n    name: \"raiinmaker\",\n    description: \"Plugin for ElizaOS to integrate with the Raiinmaker app for content verification and validation\",\n    actions: [\n        getQuestStatus,\n        getDataVerification,\n        verifyGenerationContent,\n        checkVerificationStatus\n    ],\n    evaluators: [],\n    providers: [],\n};\n\n// Export additional functions for use by other plugins or components\nexport { \n    createRaiinmakerService, \n    validateRaiinmakerConfig,\n    preVerifyContent,\n    isDevelopmentEnvironment,\n    isActionAllowedInEnvironment,\n    isPreVerificationEnabled,\n    formatVerificationStatusResponse\n};\n\nexport default raiinmakerPlugin;"],"mappings":"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","names":["elizaLogger","getDataVerification","elizaLogger","elizaLogger","elizaLogger","elizaLogger","elizaLogger","elizaLogger","elizaLogger","z","z","elizaLogger","elizaLogger","elizaLogger","z","z","elizaLogger"]}